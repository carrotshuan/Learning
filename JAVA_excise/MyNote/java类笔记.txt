一、 类操作

	在类的大部分情况下，一个方法访问该类中的其他方法或成员变量，前面都可以不加this；
	static修饰的方法中不能使用this引用；
	java编程时不要使用对象去调用static修饰的成员变量、防范，而要用类去调用；
	同一个类的一个方法调用另一个方法时，如果被调方法是普通方法，则默认使用this作为调用者，可以省略this；如果被调是static方法，则默认使用类作为调用者；

	方法：
	java的参数传递方式只有一种：值传递，就是实际参数值的副本，复制后传入方法内；
	在jdk1.5以后，java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的形参；方法为在最后一个形参后增加（...）；
	一个方法中最多只能有一个个数可变的形参，位于参数末尾；
	java的成员变量会进行默认初始化，局部变量不会进行默认初始化，局部变量必须进行显式初始化；（与成员变量不同，局部变量不属于任何类或实例，而总是保存在所在方法的栈内存中）

	【内聚性是对一个模块内部各个组成元素之间相互结合的紧密程度的度量指标；】

	何时使用成员变量：类的属性、类的状态、类方法间共享三种场景；
	java访问控制符有四种：private[类中访问]->(default[包中访问])->protect[子类中访问]->public[全部可访问]
	java文件中类名与文件名一致的类外的类不可以用public修饰符进行修饰，本类可以带也可以不带public修饰符。

	包：
	一旦在java源文件中使用package语句，就意味着该源文件里定义的所有类都属于这个包。位于包中的每个类的完整类名都应该是包名和类名的组合；
	位于包中的类，文件系统也必须有与包名结构相同的目录结构；
	编译java文件时不使用-d选项，则java不会为源文件创建目录结构；
	package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，该源文件可以定义多个类，这些类则全部位于该包下；
	使用import (.*)只能导入某个包下的类，不代表包；
	import static用于导入指定类的静态成员变量或方法；

	构造器：
	一旦程序员提供了构造器，系统就不再提供默认的构造器；
	如果一个类包含了多个构造函数，B构造函数完全包含了A构造函数的功能，则可以在B中利用this()这种形式先调用A，再进行其他动作，但必须作为构造器的第一条语句；

	继承：
	使用extends作为继承的关键字；
	java类只能有一个直接父类（单层的extends），但是可以有多个间接父类（父类的父类）；
	如果定义一个类并未指定其父类，则默认继承自java.lang.Object，即：java.lang.Object是所有类的父类；
	方法重写：两小一大原则，子类比父类方法的返回值类型更小或相等，子类方法声明抛出的异常类应比父类更小或相等；一大指的是子类方法的访问权限应比父类更大或相等；
	覆盖与被覆盖方法应该是类型相同的方法，均为类方法或实例方法；
	如果需要在子类中访问父类中被覆盖的方法，可以使用super(实例方法)或classname.方法名(类方法)
	super和this均不能出现在static修饰的方法中，因均是对实例进行的操作；
	父子类中具有相同的变量名，则子类会隐藏父类的变量，但仅仅是隐藏，仍然可以通过super.进行访问，java也会进行父类变量的初始化等操作；
	super()代表调用父类的构造器，也必须在首行；

	多态：
	JAVA的引用变量有两种类型：编译时类型、运行时类型；编译时类型与运行时类型不一致就会发生多态（父类引用变量指向子类对象）
	相同类型的变量，调用同一方法时呈现出不同的行为特征，就称为多态；但是成员变量不具备多态的特性，父类的引用变量指向子类对象，通过引用变量访问覆盖后的同名变量将还是访问的父类中的变量；

	强制类型转换
	基本类型之间的转换只能在数值之间进行（数值类型包括整数型、字符型和浮点型），数值类型和布尔类型之间不能进行类型转换；
	引用类型之间的转换只能在具有继承关系的两个类型之间进行；如果要把父类对象转换成子类对象，则必须父类对象实际上是子类对象才行（编译时为父类，运行时为子类）；
	instanceof 是一个编译时检查的运算符，判断前面的对象是否是后面的类，或其子类。
	推荐做法：在进行强制类型转换之前，要instanceof 先判断是否可以转换，从而避免ClassCastException异常。(子类实例 instanceof <待转换类型>)
	子类对象赋给父类引用时，被称为向上转型，这种转换总是成功的；但当把父类对象赋给子类引用时，就需要进行强转，而且还可能在运行时产生ClassCastException异常。

	在使用多态或继承时，父类中的变量子类同名会发生隐藏，强转为父类时可以恢复；但父类中的方法子类同名则会覆盖，强转为父类也不可恢复。
	继承表达的是is-a的关系，而组合表达的是has-a的关系；

	初始化块：
	java类有四种成员，包括变量，方法，构造器，初始化块
	初始化块的修饰符只能是static，且在java类定义执行构造函数之前先执行。
	应用场景：如果类有一段初始化代码对所有对象或构造器完成相同，且无需接收任何参数，就可以把这段代码放在初始化块中。
	静态初始化块也被称为类初始化块，会在类初始化的时候进行，所以会在对象初始化之前就进行了初始化。
	执行顺序：静态初始化块先全部执行完毕-> 各类中初始化块，构造函数，且按照从父类到子类顺序执行

二、 类增强

	字符串转基本类型方法：Java为其8种基本数据类型提供了对应的包装类：boolean->Boolean,byte->Byte,short->Short,int->Integer,long->Long,char->Character,float->Float,double->Double，每都有一个.valueOf(其他类型的字符串)静态方法，用于与字符串类型之间的相互转换(但转换的必须是对应的类型)。
	基本类型转字符串：1. String.valueOf(i)；2. 其他类.toString(类型);

	求次方：Math.pow(m,n)，m的n次方，^为按位异或操作
	随机数：Math.random()
	java 8为各个包装类提供了对应无符号运算操作的函数，如：Integer.parseUnsignedInt()；

	toString()是一个特殊的方法，在Object中已定义，用于描述当前类的信息。
	==用于判断两个基本数值类型变量值是否相等；在判断变量为引用类型的变量时，只有两个变量指向同一对象时才返回true，且不能用于判断没有继承关系的对象。
	JAVA使用常量池来管理在编译时确定的一些数据，包括字符串常量。JAVA保障在常量池中相同字符串直接量只有一个。
	Object提供的equal()方法与==方法意义相同，但String将其进行了重写，在两个字符串包含的字符序列相同时返回true。
	static修饰的类变量和方法最好通过类来访问，也可以通过对象来访问（不建议，在通过对象来访问时系统会在底层转换为通过类来访问），作为类的多个对象的共享变量或方法来使用。类成员禁止访问实例成员！

	单例模式：私有构造类变量，公共判空带返回。

	Final 修饰的普通变量只有一次赋值的运算，可以将定义与赋值分开。Final修饰的成员变量，必须由程序员显式指定初始值。
	即：类变量在声明时或静态初始化块中初始化值，实例变量在声明、非静态初始化块和构造器中初始化。
	要避免在初始化之前访问final定义的变量。如果final修饰的变量在编译时就可以确定了（包括基本运算确定），那么其就是一个宏变量，在编译时会进行宏展开。（在编译时就可以确定的变量叫宏变量）
	用Final修饰的引用变量不可以改变引用的值，但可以改变引用指向的内容的值。
	Final修饰的方法不可以被子类重写，但重载不受影响。子父类的同名同参函数，父类用private修饰，则子类的该函数不是重写，因为不可访问父类的private方法。
	Final修饰的类不可以被继承。

	类的对象中的变量不可被更改，则该类称为不可变类。JAVA提供的基本类型的包装类和java.lang.String都属于这种不可变类。实现方式：1. 用private和final修饰变量 2. 提供带参构造器，用于初始化值 3. 提供getter方法。

	设计一个不可变类，尤其是引用类型的成员变量，如果引用类型的成员变量是可变类，要考虑使用临时类等来封装达到不可变类。

	抽象类：抽象类使用abstract修饰，抽象类可以没有抽象方法。抽象方法也使用abstract修饰，抽象方法不能有方法体。
	abstract不能用于修饰成员变量、局部变量、构造器，也不能与final、private关键词同时出现。

	接口：接口是从多个类中抽象出来的规范，接口不提供任何实现，体现的是规范和实现分离的设计哲学。接口里定义的方法只能是抽象方法(abstract修饰)、类方法(static修饰)、默认方法(default修饰)或私有方法(private修饰)。在接口里如果不加任何修饰符默认添加public abstract修饰，除了抽象方法，其他方法均需要有方法体。

	接口的成员变量默认使用：public static final前缀修饰。
	默认方法总是使用public进行修饰，开发者不指定则默认系统添加，默认方法不与static连用。默认方法就是实例方法。
	类方法也总是与public修饰，开发者未指定时由系统添加，不与default连用。
	接口使用：一个类implement一个或多个接口之后，这个类必须完全实现这些接口所定义的全部抽象方法。

	组合：复用一个类，除了把这个类当成基类来继承之外，还可以把该类当成另一个类功能的一部分(定义一个同名函数，实例化基类，调用基类的该函数即可)，组合实现，这就是组合。
	接口也支持多态；

	内部类：一个定义在类内部的类被称为内部类(或嵌套类)，内部类外的类也叫外部类(或宿主类)，内部类提供了更好的封装特性。内部类作为外部类的成员，可以访问外部类的私有数据。
	匿名内部类适合于创建使用仅需要一次使用的类。非静态内部类不能拥有静态成员。可以在类的内部任何位置定义内部类，甚至是在类的方法中。
	内部类的class文件总是这种形式：OuterClass$InnerClass.class，在内部类中访问同名变量的方式->OutterClass.this.varName(外部类变量),this.varName(内部类变量),varName(局部变量)

	静态内部类：
	非静态内部类里不能有静态方法、静态成员变量、静态初始化块

	用static修饰内部类，则这个类就属于外部类本身(用static修饰的成员都属于类本身，不属于实例本身)，不属于外部类的某个对象，因此用static修饰的内部类被称为类内部类，也叫静态内部类。

	static只可以修饰内部类，不可以修饰外部类，外部类只能包含静态成员，java没有把类分离出单独的静态类种类。
	接口中定义的内部类都会使用public static进行修饰，接口内部类只能是静态内部类。

	在外部类以外使用定义的内部类(要求内部类的修饰符不能为private，需要为default、public等可被访问到的权限)，完整的声明方式是：OutterClass.InnerClass varName;
	在外部类以外的地方创建非静态内部类语法：OutterInstance.new InnerConstructor()；

	静态内部类是外部内的一个静态成员，外部类的所有方法及初始化块均可以使用静态内部类来定义变量，创建对象，静态内部类使用方法与静态属性一致。
	静态内部类的普通（实例）方法，带static关键字就作为类属性来对待，不带static则作为需要实例化后普通对象来对待，此时静态类相当于普通类。
	外部类使用内部静态类 Outer.Inner oi = new Outer.Inner(); oi.function();

	局部内部类：内部类放在方法里定义，则成为局部类，局部内部类仅在方法体里有效，也不能使用访问控制符和static修饰符修饰（由于作用域很小使用场景极少）。
	匿名内部类：适合于创建那种只需要使用一次的类。定义内部类无需class关键字，匿名内部类不能是抽象类，匿名内部类不能定义构造器，因为其没有类名（内部包含一个隐式无参构造器）。
	匿名内部类使用格式 new 接口/父类构造器(参数) { //内部类类体部分 }


	函数式接口：函数式接口代表只包含一个抽象方法的接口。其可以包含多个默认方法、类方法，但只能声明一个抽象方法。对应java的@FunctionInterface注解，告诉编译器执行更高检查，确认接口属于函数式接口标准。
	lambda表达式的类型叫做目标类型，lambda表达式的目标类型必须是函数式接口。lambda表达式的返回值可以是任意对象，实际类型取决于实际情况。
	lambda表达式的目标类型必须是明确的函数式接口，且只能为函数式接口创建对象。
	lambda表达式是匿名内部类的一种简化，可以取代部分匿名内部类的作用。::是lambda表达式的一种简化使用方式。

	枚举类：枚举类是一种特殊的类，它可以有自己的成员变量、方法和构造器。枚举类默认继承java.lang.Enum类，非Object类。
	使用：枚举类 变量 = 枚举类.枚举值;






